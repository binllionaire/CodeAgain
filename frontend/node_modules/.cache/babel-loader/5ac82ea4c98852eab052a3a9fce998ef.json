{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTraversal = void 0;\nvar css_what_1 = require(\"css-what\");\nvar procedure = new Map([[css_what_1.SelectorType.Universal, 50], [css_what_1.SelectorType.Tag, 30], [css_what_1.SelectorType.Attribute, 1], [css_what_1.SelectorType.Pseudo, 0]]);\nfunction isTraversal(token) {\n  return !procedure.has(token.type);\n}\nexports.isTraversal = isTraversal;\nvar attributes = new Map([[css_what_1.AttributeAction.Exists, 10], [css_what_1.AttributeAction.Equals, 8], [css_what_1.AttributeAction.Not, 7], [css_what_1.AttributeAction.Start, 6], [css_what_1.AttributeAction.End, 6], [css_what_1.AttributeAction.Any, 5]]);\n/**\n * Sort the parts of the passed selector,\n * as there is potential for optimization\n * (some types of selectors are faster than others)\n *\n * @param arr Selector to sort\n */\nfunction sortByProcedure(arr) {\n  var procs = arr.map(getProcedure);\n  for (var i = 1; i < arr.length; i++) {\n    var procNew = procs[i];\n    if (procNew < 0) continue;\n    for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {\n      var token = arr[j + 1];\n      arr[j + 1] = arr[j];\n      arr[j] = token;\n      procs[j + 1] = procs[j];\n      procs[j] = procNew;\n    }\n  }\n}\nexports.default = sortByProcedure;\nfunction getProcedure(token) {\n  var _a, _b;\n  var proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;\n  if (token.type === css_what_1.SelectorType.Attribute) {\n    proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;\n    if (token.action === css_what_1.AttributeAction.Equals && token.name === \"id\") {\n      // Prefer ID selectors (eg. #ID)\n      proc = 9;\n    }\n    if (token.ignoreCase) {\n      /*\n       * IgnoreCase adds some overhead, prefer \"normal\" token\n       * this is a binary operation, to ensure it's still an int\n       */\n      proc >>= 1;\n    }\n  } else if (token.type === css_what_1.SelectorType.Pseudo) {\n    if (!token.data) {\n      proc = 3;\n    } else if (token.name === \"has\" || token.name === \"contains\") {\n      proc = 0; // Expensive in any case\n    } else if (Array.isArray(token.data)) {\n      // Eg. :matches, :not\n      proc = Math.min.apply(Math, token.data.map(function (d) {\n        return Math.min.apply(Math, d.map(getProcedure));\n      }));\n      // If we have traversals, try to avoid executing this selector\n      if (proc < 0) {\n        proc = 0;\n      }\n    } else {\n      proc = 2;\n    }\n  }\n  return proc;\n}\n//# sourceMappingURL=sort.js.map","map":null,"metadata":{},"sourceType":"script"}