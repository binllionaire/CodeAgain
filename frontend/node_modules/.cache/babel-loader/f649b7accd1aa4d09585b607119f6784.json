{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tokenizer = exports.TokenizerMode = void 0;\nconst preprocessor_js_1 = require(\"./preprocessor.js\");\nconst unicode_js_1 = require(\"../common/unicode.js\");\nconst token_js_1 = require(\"../common/token.js\");\nconst decode_js_1 = require(\"entities/lib/decode.js\");\nconst error_codes_js_1 = require(\"../common/error-codes.js\");\nconst html_js_1 = require(\"../common/html.js\");\n//C1 Unicode control character reference replacements\nconst C1_CONTROLS_REFERENCE_REPLACEMENTS = new Map([[0x80, 8364], [0x82, 8218], [0x83, 402], [0x84, 8222], [0x85, 8230], [0x86, 8224], [0x87, 8225], [0x88, 710], [0x89, 8240], [0x8a, 352], [0x8b, 8249], [0x8c, 338], [0x8e, 381], [0x91, 8216], [0x92, 8217], [0x93, 8220], [0x94, 8221], [0x95, 8226], [0x96, 8211], [0x97, 8212], [0x98, 732], [0x99, 8482], [0x9a, 353], [0x9b, 8250], [0x9c, 339], [0x9e, 382], [0x9f, 376]]);\n//States\nvar State;\n(function (State) {\n  State[State[\"DATA\"] = 0] = \"DATA\";\n  State[State[\"RCDATA\"] = 1] = \"RCDATA\";\n  State[State[\"RAWTEXT\"] = 2] = \"RAWTEXT\";\n  State[State[\"SCRIPT_DATA\"] = 3] = \"SCRIPT_DATA\";\n  State[State[\"PLAINTEXT\"] = 4] = \"PLAINTEXT\";\n  State[State[\"TAG_OPEN\"] = 5] = \"TAG_OPEN\";\n  State[State[\"END_TAG_OPEN\"] = 6] = \"END_TAG_OPEN\";\n  State[State[\"TAG_NAME\"] = 7] = \"TAG_NAME\";\n  State[State[\"RCDATA_LESS_THAN_SIGN\"] = 8] = \"RCDATA_LESS_THAN_SIGN\";\n  State[State[\"RCDATA_END_TAG_OPEN\"] = 9] = \"RCDATA_END_TAG_OPEN\";\n  State[State[\"RCDATA_END_TAG_NAME\"] = 10] = \"RCDATA_END_TAG_NAME\";\n  State[State[\"RAWTEXT_LESS_THAN_SIGN\"] = 11] = \"RAWTEXT_LESS_THAN_SIGN\";\n  State[State[\"RAWTEXT_END_TAG_OPEN\"] = 12] = \"RAWTEXT_END_TAG_OPEN\";\n  State[State[\"RAWTEXT_END_TAG_NAME\"] = 13] = \"RAWTEXT_END_TAG_NAME\";\n  State[State[\"SCRIPT_DATA_LESS_THAN_SIGN\"] = 14] = \"SCRIPT_DATA_LESS_THAN_SIGN\";\n  State[State[\"SCRIPT_DATA_END_TAG_OPEN\"] = 15] = \"SCRIPT_DATA_END_TAG_OPEN\";\n  State[State[\"SCRIPT_DATA_END_TAG_NAME\"] = 16] = \"SCRIPT_DATA_END_TAG_NAME\";\n  State[State[\"SCRIPT_DATA_ESCAPE_START\"] = 17] = \"SCRIPT_DATA_ESCAPE_START\";\n  State[State[\"SCRIPT_DATA_ESCAPE_START_DASH\"] = 18] = \"SCRIPT_DATA_ESCAPE_START_DASH\";\n  State[State[\"SCRIPT_DATA_ESCAPED\"] = 19] = \"SCRIPT_DATA_ESCAPED\";\n  State[State[\"SCRIPT_DATA_ESCAPED_DASH\"] = 20] = \"SCRIPT_DATA_ESCAPED_DASH\";\n  State[State[\"SCRIPT_DATA_ESCAPED_DASH_DASH\"] = 21] = \"SCRIPT_DATA_ESCAPED_DASH_DASH\";\n  State[State[\"SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN\"] = 22] = \"SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN\";\n  State[State[\"SCRIPT_DATA_ESCAPED_END_TAG_OPEN\"] = 23] = \"SCRIPT_DATA_ESCAPED_END_TAG_OPEN\";\n  State[State[\"SCRIPT_DATA_ESCAPED_END_TAG_NAME\"] = 24] = \"SCRIPT_DATA_ESCAPED_END_TAG_NAME\";\n  State[State[\"SCRIPT_DATA_DOUBLE_ESCAPE_START\"] = 25] = \"SCRIPT_DATA_DOUBLE_ESCAPE_START\";\n  State[State[\"SCRIPT_DATA_DOUBLE_ESCAPED\"] = 26] = \"SCRIPT_DATA_DOUBLE_ESCAPED\";\n  State[State[\"SCRIPT_DATA_DOUBLE_ESCAPED_DASH\"] = 27] = \"SCRIPT_DATA_DOUBLE_ESCAPED_DASH\";\n  State[State[\"SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH\"] = 28] = \"SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH\";\n  State[State[\"SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN\"] = 29] = \"SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN\";\n  State[State[\"SCRIPT_DATA_DOUBLE_ESCAPE_END\"] = 30] = \"SCRIPT_DATA_DOUBLE_ESCAPE_END\";\n  State[State[\"BEFORE_ATTRIBUTE_NAME\"] = 31] = \"BEFORE_ATTRIBUTE_NAME\";\n  State[State[\"ATTRIBUTE_NAME\"] = 32] = \"ATTRIBUTE_NAME\";\n  State[State[\"AFTER_ATTRIBUTE_NAME\"] = 33] = \"AFTER_ATTRIBUTE_NAME\";\n  State[State[\"BEFORE_ATTRIBUTE_VALUE\"] = 34] = \"BEFORE_ATTRIBUTE_VALUE\";\n  State[State[\"ATTRIBUTE_VALUE_DOUBLE_QUOTED\"] = 35] = \"ATTRIBUTE_VALUE_DOUBLE_QUOTED\";\n  State[State[\"ATTRIBUTE_VALUE_SINGLE_QUOTED\"] = 36] = \"ATTRIBUTE_VALUE_SINGLE_QUOTED\";\n  State[State[\"ATTRIBUTE_VALUE_UNQUOTED\"] = 37] = \"ATTRIBUTE_VALUE_UNQUOTED\";\n  State[State[\"AFTER_ATTRIBUTE_VALUE_QUOTED\"] = 38] = \"AFTER_ATTRIBUTE_VALUE_QUOTED\";\n  State[State[\"SELF_CLOSING_START_TAG\"] = 39] = \"SELF_CLOSING_START_TAG\";\n  State[State[\"BOGUS_COMMENT\"] = 40] = \"BOGUS_COMMENT\";\n  State[State[\"MARKUP_DECLARATION_OPEN\"] = 41] = \"MARKUP_DECLARATION_OPEN\";\n  State[State[\"COMMENT_START\"] = 42] = \"COMMENT_START\";\n  State[State[\"COMMENT_START_DASH\"] = 43] = \"COMMENT_START_DASH\";\n  State[State[\"COMMENT\"] = 44] = \"COMMENT\";\n  State[State[\"COMMENT_LESS_THAN_SIGN\"] = 45] = \"COMMENT_LESS_THAN_SIGN\";\n  State[State[\"COMMENT_LESS_THAN_SIGN_BANG\"] = 46] = \"COMMENT_LESS_THAN_SIGN_BANG\";\n  State[State[\"COMMENT_LESS_THAN_SIGN_BANG_DASH\"] = 47] = \"COMMENT_LESS_THAN_SIGN_BANG_DASH\";\n  State[State[\"COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH\"] = 48] = \"COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH\";\n  State[State[\"COMMENT_END_DASH\"] = 49] = \"COMMENT_END_DASH\";\n  State[State[\"COMMENT_END\"] = 50] = \"COMMENT_END\";\n  State[State[\"COMMENT_END_BANG\"] = 51] = \"COMMENT_END_BANG\";\n  State[State[\"DOCTYPE\"] = 52] = \"DOCTYPE\";\n  State[State[\"BEFORE_DOCTYPE_NAME\"] = 53] = \"BEFORE_DOCTYPE_NAME\";\n  State[State[\"DOCTYPE_NAME\"] = 54] = \"DOCTYPE_NAME\";\n  State[State[\"AFTER_DOCTYPE_NAME\"] = 55] = \"AFTER_DOCTYPE_NAME\";\n  State[State[\"AFTER_DOCTYPE_PUBLIC_KEYWORD\"] = 56] = \"AFTER_DOCTYPE_PUBLIC_KEYWORD\";\n  State[State[\"BEFORE_DOCTYPE_PUBLIC_IDENTIFIER\"] = 57] = \"BEFORE_DOCTYPE_PUBLIC_IDENTIFIER\";\n  State[State[\"DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED\"] = 58] = \"DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED\";\n  State[State[\"DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED\"] = 59] = \"DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED\";\n  State[State[\"AFTER_DOCTYPE_PUBLIC_IDENTIFIER\"] = 60] = \"AFTER_DOCTYPE_PUBLIC_IDENTIFIER\";\n  State[State[\"BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS\"] = 61] = \"BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS\";\n  State[State[\"AFTER_DOCTYPE_SYSTEM_KEYWORD\"] = 62] = \"AFTER_DOCTYPE_SYSTEM_KEYWORD\";\n  State[State[\"BEFORE_DOCTYPE_SYSTEM_IDENTIFIER\"] = 63] = \"BEFORE_DOCTYPE_SYSTEM_IDENTIFIER\";\n  State[State[\"DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED\"] = 64] = \"DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED\";\n  State[State[\"DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED\"] = 65] = \"DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED\";\n  State[State[\"AFTER_DOCTYPE_SYSTEM_IDENTIFIER\"] = 66] = \"AFTER_DOCTYPE_SYSTEM_IDENTIFIER\";\n  State[State[\"BOGUS_DOCTYPE\"] = 67] = \"BOGUS_DOCTYPE\";\n  State[State[\"CDATA_SECTION\"] = 68] = \"CDATA_SECTION\";\n  State[State[\"CDATA_SECTION_BRACKET\"] = 69] = \"CDATA_SECTION_BRACKET\";\n  State[State[\"CDATA_SECTION_END\"] = 70] = \"CDATA_SECTION_END\";\n  State[State[\"CHARACTER_REFERENCE\"] = 71] = \"CHARACTER_REFERENCE\";\n  State[State[\"NAMED_CHARACTER_REFERENCE\"] = 72] = \"NAMED_CHARACTER_REFERENCE\";\n  State[State[\"AMBIGUOUS_AMPERSAND\"] = 73] = \"AMBIGUOUS_AMPERSAND\";\n  State[State[\"NUMERIC_CHARACTER_REFERENCE\"] = 74] = \"NUMERIC_CHARACTER_REFERENCE\";\n  State[State[\"HEXADEMICAL_CHARACTER_REFERENCE_START\"] = 75] = \"HEXADEMICAL_CHARACTER_REFERENCE_START\";\n  State[State[\"HEXADEMICAL_CHARACTER_REFERENCE\"] = 76] = \"HEXADEMICAL_CHARACTER_REFERENCE\";\n  State[State[\"DECIMAL_CHARACTER_REFERENCE\"] = 77] = \"DECIMAL_CHARACTER_REFERENCE\";\n  State[State[\"NUMERIC_CHARACTER_REFERENCE_END\"] = 78] = \"NUMERIC_CHARACTER_REFERENCE_END\";\n})(State || (State = {}));\n//Tokenizer initial states for different modes\nexports.TokenizerMode = {\n  DATA: State.DATA,\n  RCDATA: State.RCDATA,\n  RAWTEXT: State.RAWTEXT,\n  SCRIPT_DATA: State.SCRIPT_DATA,\n  PLAINTEXT: State.PLAINTEXT,\n  CDATA_SECTION: State.CDATA_SECTION\n};\n//Utils\n//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline\n//this functions if they will be situated in another module due to context switch.\n//Always perform inlining check before modifying this functions ('node --trace-inlining').\nfunction isAsciiDigit(cp) {\n  return cp >= unicode_js_1.CODE_POINTS.DIGIT_0 && cp <= unicode_js_1.CODE_POINTS.DIGIT_9;\n}\nfunction isAsciiUpper(cp) {\n  return cp >= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_Z;\n}\nfunction isAsciiLower(cp) {\n  return cp >= unicode_js_1.CODE_POINTS.LATIN_SMALL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_SMALL_Z;\n}\nfunction isAsciiLetter(cp) {\n  return isAsciiLower(cp) || isAsciiUpper(cp);\n}\nfunction isAsciiAlphaNumeric(cp) {\n  return isAsciiLetter(cp) || isAsciiDigit(cp);\n}\nfunction isAsciiUpperHexDigit(cp) {\n  return cp >= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_F;\n}\nfunction isAsciiLowerHexDigit(cp) {\n  return cp >= unicode_js_1.CODE_POINTS.LATIN_SMALL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_SMALL_F;\n}\nfunction isAsciiHexDigit(cp) {\n  return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);\n}\nfunction toAsciiLower(cp) {\n  return cp + 32;\n}\nfunction isWhitespace(cp) {\n  return cp === unicode_js_1.CODE_POINTS.SPACE || cp === unicode_js_1.CODE_POINTS.LINE_FEED || cp === unicode_js_1.CODE_POINTS.TABULATION || cp === unicode_js_1.CODE_POINTS.FORM_FEED;\n}\nfunction isEntityInAttributeInvalidEnd(nextCp) {\n  return nextCp === unicode_js_1.CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);\n}\nfunction isScriptDataDoubleEscapeSequenceEnd(cp) {\n  return isWhitespace(cp) || cp === unicode_js_1.CODE_POINTS.SOLIDUS || cp === unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN;\n}\n//Tokenizer\nclass Tokenizer {\n  constructor(options, handler) {\n    this.options = options;\n    this.handler = handler;\n    this.paused = false;\n    /** Ensures that the parsing loop isn't run multiple times at once. */\n    this.inLoop = false;\n    /**\n     * Indicates that the current adjusted node exists, is not an element in the HTML namespace,\n     * and that it is not an integration point for either MathML or HTML.\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/parsing.html#tree-construction}\n     */\n    this.inForeignNode = false;\n    this.lastStartTagName = '';\n    this.active = false;\n    this.state = State.DATA;\n    this.returnState = State.DATA;\n    this.charRefCode = -1;\n    this.consumedAfterSnapshot = -1;\n    this.currentCharacterToken = null;\n    this.currentToken = null;\n    this.currentAttr = {\n      name: '',\n      value: ''\n    };\n    this.preprocessor = new preprocessor_js_1.Preprocessor(handler);\n    this.currentLocation = this.getCurrentLocation(-1);\n  }\n  //Errors\n  _err(code) {\n    var _a, _b;\n    (_b = (_a = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a, this.preprocessor.getError(code));\n  }\n  // NOTE: `offset` may never run across line boundaries.\n  getCurrentLocation(offset) {\n    if (!this.options.sourceCodeLocationInfo) {\n      return null;\n    }\n    return {\n      startLine: this.preprocessor.line,\n      startCol: this.preprocessor.col - offset,\n      startOffset: this.preprocessor.offset - offset,\n      endLine: -1,\n      endCol: -1,\n      endOffset: -1\n    };\n  }\n  _runParsingLoop() {\n    if (this.inLoop) return;\n    this.inLoop = true;\n    while (this.active && !this.paused) {\n      this.consumedAfterSnapshot = 0;\n      const cp = this._consume();\n      if (!this._ensureHibernation()) {\n        this._callState(cp);\n      }\n    }\n    this.inLoop = false;\n  }\n  //API\n  pause() {\n    this.paused = true;\n  }\n  resume(writeCallback) {\n    if (!this.paused) {\n      throw new Error('Parser was already resumed');\n    }\n    this.paused = false;\n    // Necessary for synchronous resume.\n    if (this.inLoop) return;\n    this._runParsingLoop();\n    if (!this.paused) {\n      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();\n    }\n  }\n  write(chunk, isLastChunk, writeCallback) {\n    this.active = true;\n    this.preprocessor.write(chunk, isLastChunk);\n    this._runParsingLoop();\n    if (!this.paused) {\n      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();\n    }\n  }\n  insertHtmlAtCurrentPos(chunk) {\n    this.active = true;\n    this.preprocessor.insertHtmlAtCurrentPos(chunk);\n    this._runParsingLoop();\n  }\n  //Hibernation\n  _ensureHibernation() {\n    if (this.preprocessor.endOfChunkHit) {\n      this._unconsume(this.consumedAfterSnapshot);\n      this.active = false;\n      return true;\n    }\n    return false;\n  }\n  //Consumption\n  _consume() {\n    this.consumedAfterSnapshot++;\n    return this.preprocessor.advance();\n  }\n  _unconsume(count) {\n    this.consumedAfterSnapshot -= count;\n    this.preprocessor.retreat(count);\n  }\n  _reconsumeInState(state, cp) {\n    this.state = state;\n    this._callState(cp);\n  }\n  _advanceBy(count) {\n    this.consumedAfterSnapshot += count;\n    for (let i = 0; i < count; i++) {\n      this.preprocessor.advance();\n    }\n  }\n  _consumeSequenceIfMatch(pattern, caseSensitive) {\n    if (this.preprocessor.startsWith(pattern, caseSensitive)) {\n      // We will already have consumed one character before calling this method.\n      this._advanceBy(pattern.length - 1);\n      return true;\n    }\n    return false;\n  }\n  //Token creation\n  _createStartTagToken() {\n    this.currentToken = {\n      type: token_js_1.TokenType.START_TAG,\n      tagName: '',\n      tagID: html_js_1.TAG_ID.UNKNOWN,\n      selfClosing: false,\n      ackSelfClosing: false,\n      attrs: [],\n      location: this.getCurrentLocation(1)\n    };\n  }\n  _createEndTagToken() {\n    this.currentToken = {\n      type: token_js_1.TokenType.END_TAG,\n      tagName: '',\n      tagID: html_js_1.TAG_ID.UNKNOWN,\n      selfClosing: false,\n      ackSelfClosing: false,\n      attrs: [],\n      location: this.getCurrentLocation(2)\n    };\n  }\n  _createCommentToken(offset) {\n    this.currentToken = {\n      type: token_js_1.TokenType.COMMENT,\n      data: '',\n      location: this.getCurrentLocation(offset)\n    };\n  }\n  _createDoctypeToken(initialName) {\n    this.currentToken = {\n      type: token_js_1.TokenType.DOCTYPE,\n      name: initialName,\n      forceQuirks: false,\n      publicId: null,\n      systemId: null,\n      location: this.currentLocation\n    };\n  }\n  _createCharacterToken(type, chars) {\n    this.currentCharacterToken = {\n      type,\n      chars,\n      location: this.currentLocation\n    };\n  }\n  //Tag attributes\n  _createAttr(attrNameFirstCh) {\n    this.currentAttr = {\n      name: attrNameFirstCh,\n      value: ''\n    };\n    this.currentLocation = this.getCurrentLocation(0);\n  }\n  _leaveAttrName() {\n    var _a;\n    var _b;\n    const token = this.currentToken;\n    if ((0, token_js_1.getTokenAttr)(token, this.currentAttr.name) === null) {\n      token.attrs.push(this.currentAttr);\n      if (token.location && this.currentLocation) {\n        const attrLocations = (_a = (_b = token.location).attrs) !== null && _a !== void 0 ? _a : _b.attrs = Object.create(null);\n        attrLocations[this.currentAttr.name] = this.currentLocation;\n        // Set end location\n        this._leaveAttrValue();\n      }\n    } else {\n      this._err(error_codes_js_1.ERR.duplicateAttribute);\n    }\n  }\n  _leaveAttrValue() {\n    if (this.currentLocation) {\n      this.currentLocation.endLine = this.preprocessor.line;\n      this.currentLocation.endCol = this.preprocessor.col;\n      this.currentLocation.endOffset = this.preprocessor.offset;\n    }\n  }\n  //Token emission\n  prepareToken(ct) {\n    this._emitCurrentCharacterToken(ct.location);\n    this.currentToken = null;\n    if (ct.location) {\n      ct.location.endLine = this.preprocessor.line;\n      ct.location.endCol = this.preprocessor.col + 1;\n      ct.location.endOffset = this.preprocessor.offset + 1;\n    }\n    this.currentLocation = this.getCurrentLocation(-1);\n  }\n  emitCurrentTagToken() {\n    const ct = this.currentToken;\n    this.prepareToken(ct);\n    ct.tagID = (0, html_js_1.getTagID)(ct.tagName);\n    if (ct.type === token_js_1.TokenType.START_TAG) {\n      this.lastStartTagName = ct.tagName;\n      this.handler.onStartTag(ct);\n    } else {\n      if (ct.attrs.length > 0) {\n        this._err(error_codes_js_1.ERR.endTagWithAttributes);\n      }\n      if (ct.selfClosing) {\n        this._err(error_codes_js_1.ERR.endTagWithTrailingSolidus);\n      }\n      this.handler.onEndTag(ct);\n    }\n    this.preprocessor.dropParsedChunk();\n  }\n  emitCurrentComment(ct) {\n    this.prepareToken(ct);\n    this.handler.onComment(ct);\n    this.preprocessor.dropParsedChunk();\n  }\n  emitCurrentDoctype(ct) {\n    this.prepareToken(ct);\n    this.handler.onDoctype(ct);\n    this.preprocessor.dropParsedChunk();\n  }\n  _emitCurrentCharacterToken(nextLocation) {\n    if (this.currentCharacterToken) {\n      //NOTE: if we have a pending character token, make it's end location equal to the\n      //current token's start location.\n      if (nextLocation && this.currentCharacterToken.location) {\n        this.currentCharacterToken.location.endLine = nextLocation.startLine;\n        this.currentCharacterToken.location.endCol = nextLocation.startCol;\n        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;\n      }\n      switch (this.currentCharacterToken.type) {\n        case token_js_1.TokenType.CHARACTER:\n          {\n            this.handler.onCharacter(this.currentCharacterToken);\n            break;\n          }\n        case token_js_1.TokenType.NULL_CHARACTER:\n          {\n            this.handler.onNullCharacter(this.currentCharacterToken);\n            break;\n          }\n        case token_js_1.TokenType.WHITESPACE_CHARACTER:\n          {\n            this.handler.onWhitespaceCharacter(this.currentCharacterToken);\n            break;\n          }\n      }\n      this.currentCharacterToken = null;\n    }\n  }\n  _emitEOFToken() {\n    const location = this.getCurrentLocation(0);\n    if (location) {\n      location.endLine = location.startLine;\n      location.endCol = location.startCol;\n      location.endOffset = location.startOffset;\n    }\n    this._emitCurrentCharacterToken(location);\n    this.handler.onEof({\n      type: token_js_1.TokenType.EOF,\n      location\n    });\n    this.active = false;\n  }\n  //Characters emission\n  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).\n  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.\n  //If we have a sequence of characters that belong to the same group, the parser can process it\n  //as a single solid character token.\n  //So, there are 3 types of character tokens in parse5:\n  //1)TokenType.NULL_CHARACTER - \\u0000-character sequences (e.g. '\\u0000\\u0000\\u0000')\n  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\\n  \\r\\t   \\f')\n  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')\n  _appendCharToCurrentCharacterToken(type, ch) {\n    if (this.currentCharacterToken) {\n      if (this.currentCharacterToken.type !== type) {\n        this.currentLocation = this.getCurrentLocation(0);\n        this._emitCurrentCharacterToken(this.currentLocation);\n        this.preprocessor.dropParsedChunk();\n      } else {\n        this.currentCharacterToken.chars += ch;\n        return;\n      }\n    }\n    this._createCharacterToken(type, ch);\n  }\n  _emitCodePoint(cp) {\n    const type = isWhitespace(cp) ? token_js_1.TokenType.WHITESPACE_CHARACTER : cp === unicode_js_1.CODE_POINTS.NULL ? token_js_1.TokenType.NULL_CHARACTER : token_js_1.TokenType.CHARACTER;\n    this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));\n  }\n  //NOTE: used when we emit characters explicitly.\n  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.\n  _emitChars(ch) {\n    this._appendCharToCurrentCharacterToken(token_js_1.TokenType.CHARACTER, ch);\n  }\n  // Character reference helpers\n  _matchNamedCharacterReference(cp) {\n    let result = null;\n    let excess = 0;\n    let withoutSemicolon = false;\n    for (let i = 0, current = decode_js_1.htmlDecodeTree[0]; i >= 0; cp = this._consume()) {\n      i = (0, decode_js_1.determineBranch)(decode_js_1.htmlDecodeTree, current, i + 1, cp);\n      if (i < 0) break;\n      excess += 1;\n      current = decode_js_1.htmlDecodeTree[i];\n      const masked = current & decode_js_1.BinTrieFlags.VALUE_LENGTH;\n      // If the branch is a value, store it and continue\n      if (masked) {\n        // The mask is the number of bytes of the value, including the current byte.\n        const valueLength = (masked >> 14) - 1;\n        // Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.\n        // See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state\n        if (cp !== unicode_js_1.CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd(this.preprocessor.peek(1))) {\n          //NOTE: we don't flush all consumed code points here, and instead switch back to the original state after\n          //emitting an ampersand. This is fine, as alphanumeric characters won't be parsed differently in attributes.\n          result = [unicode_js_1.CODE_POINTS.AMPERSAND];\n          // Skip over the value.\n          i += valueLength;\n        } else {\n          // If this is a surrogate pair, consume the next two bytes.\n          result = valueLength === 0 ? [decode_js_1.htmlDecodeTree[i] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH] : valueLength === 1 ? [decode_js_1.htmlDecodeTree[++i]] : [decode_js_1.htmlDecodeTree[++i], decode_js_1.htmlDecodeTree[++i]];\n          excess = 0;\n          withoutSemicolon = cp !== unicode_js_1.CODE_POINTS.SEMICOLON;\n        }\n        if (valueLength === 0) {\n          // If the value is zero-length, we're done.\n          this._consume();\n          break;\n        }\n      }\n    }\n    this._unconsume(excess);\n    if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {\n      this._err(error_codes_js_1.ERR.missingSemicolonAfterCharacterReference);\n    }\n    // We want to emit the error above on the code point after the entity.\n    // We always consume one code point too many in the loop, and we wait to\n    // unconsume it until after the error is emitted.\n    this._unconsume(1);\n    return result;\n  }\n  _isCharacterReferenceInAttribute() {\n    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;\n  }\n  _flushCodePointConsumedAsCharacterReference(cp) {\n    if (this._isCharacterReferenceInAttribute()) {\n      this.currentAttr.value += String.fromCodePoint(cp);\n    } else {\n      this._emitCodePoint(cp);\n    }\n  }\n  // Calling states this way turns out to be much faster than any other approach.\n  _callState(cp) {\n    switch (this.state) {\n      case State.DATA:\n        {\n          this._stateData(cp);\n          break;\n        }\n      case State.RCDATA:\n        {\n          this._stateRcdata(cp);\n          break;\n        }\n      case State.RAWTEXT:\n        {\n          this._stateRawtext(cp);\n          break;\n        }\n      case State.SCRIPT_DATA:\n        {\n          this._stateScriptData(cp);\n          break;\n        }\n      case State.PLAINTEXT:\n        {\n          this._statePlaintext(cp);\n          break;\n        }\n      case State.TAG_OPEN:\n        {\n          this._stateTagOpen(cp);\n          break;\n        }\n      case State.END_TAG_OPEN:\n        {\n          this._stateEndTagOpen(cp);\n          break;\n        }\n      case State.TAG_NAME:\n        {\n          this._stateTagName(cp);\n          break;\n        }\n      case State.RCDATA_LESS_THAN_SIGN:\n        {\n          this._stateRcdataLessThanSign(cp);\n          break;\n        }\n      case State.RCDATA_END_TAG_OPEN:\n        {\n          this._stateRcdataEndTagOpen(cp);\n          break;\n        }\n      case State.RCDATA_END_TAG_NAME:\n        {\n          this._stateRcdataEndTagName(cp);\n          break;\n        }\n      case State.RAWTEXT_LESS_THAN_SIGN:\n        {\n          this._stateRawtextLessThanSign(cp);\n          break;\n        }\n      case State.RAWTEXT_END_TAG_OPEN:\n        {\n          this._stateRawtextEndTagOpen(cp);\n          break;\n        }\n      case State.RAWTEXT_END_TAG_NAME:\n        {\n          this._stateRawtextEndTagName(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_LESS_THAN_SIGN:\n        {\n          this._stateScriptDataLessThanSign(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_END_TAG_OPEN:\n        {\n          this._stateScriptDataEndTagOpen(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_END_TAG_NAME:\n        {\n          this._stateScriptDataEndTagName(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_ESCAPE_START:\n        {\n          this._stateScriptDataEscapeStart(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_ESCAPE_START_DASH:\n        {\n          this._stateScriptDataEscapeStartDash(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_ESCAPED:\n        {\n          this._stateScriptDataEscaped(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_ESCAPED_DASH:\n        {\n          this._stateScriptDataEscapedDash(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_ESCAPED_DASH_DASH:\n        {\n          this._stateScriptDataEscapedDashDash(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:\n        {\n          this._stateScriptDataEscapedLessThanSign(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:\n        {\n          this._stateScriptDataEscapedEndTagOpen(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME:\n        {\n          this._stateScriptDataEscapedEndTagName(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START:\n        {\n          this._stateScriptDataDoubleEscapeStart(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_DOUBLE_ESCAPED:\n        {\n          this._stateScriptDataDoubleEscaped(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH:\n        {\n          this._stateScriptDataDoubleEscapedDash(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH:\n        {\n          this._stateScriptDataDoubleEscapedDashDash(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN:\n        {\n          this._stateScriptDataDoubleEscapedLessThanSign(cp);\n          break;\n        }\n      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END:\n        {\n          this._stateScriptDataDoubleEscapeEnd(cp);\n          break;\n        }\n      case State.BEFORE_ATTRIBUTE_NAME:\n        {\n          this._stateBeforeAttributeName(cp);\n          break;\n        }\n      case State.ATTRIBUTE_NAME:\n        {\n          this._stateAttributeName(cp);\n          break;\n        }\n      case State.AFTER_ATTRIBUTE_NAME:\n        {\n          this._stateAfterAttributeName(cp);\n          break;\n        }\n      case State.BEFORE_ATTRIBUTE_VALUE:\n        {\n          this._stateBeforeAttributeValue(cp);\n          break;\n        }\n      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED:\n        {\n          this._stateAttributeValueDoubleQuoted(cp);\n          break;\n        }\n      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED:\n        {\n          this._stateAttributeValueSingleQuoted(cp);\n          break;\n        }\n      case State.ATTRIBUTE_VALUE_UNQUOTED:\n        {\n          this._stateAttributeValueUnquoted(cp);\n          break;\n        }\n      case State.AFTER_ATTRIBUTE_VALUE_QUOTED:\n        {\n          this._stateAfterAttributeValueQuoted(cp);\n          break;\n        }\n      case State.SELF_CLOSING_START_TAG:\n        {\n          this._stateSelfClosingStartTag(cp);\n          break;\n        }\n      case State.BOGUS_COMMENT:\n        {\n          this._stateBogusComment(cp);\n          break;\n        }\n      case State.MARKUP_DECLARATION_OPEN:\n        {\n          this._stateMarkupDeclarationOpen(cp);\n          break;\n        }\n      case State.COMMENT_START:\n        {\n          this._stateCommentStart(cp);\n          break;\n        }\n      case State.COMMENT_START_DASH:\n        {\n          this._stateCommentStartDash(cp);\n          break;\n        }\n      case State.COMMENT:\n        {\n          this._stateComment(cp);\n          break;\n        }\n      case State.COMMENT_LESS_THAN_SIGN:\n        {\n          this._stateCommentLessThanSign(cp);\n          break;\n        }\n      case State.COMMENT_LESS_THAN_SIGN_BANG:\n        {\n          this._stateCommentLessThanSignBang(cp);\n          break;\n        }\n      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH:\n        {\n          this._stateCommentLessThanSignBangDash(cp);\n          break;\n        }\n      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:\n        {\n          this._stateCommentLessThanSignBangDashDash(cp);\n          break;\n        }\n      case State.COMMENT_END_DASH:\n        {\n          this._stateCommentEndDash(cp);\n          break;\n        }\n      case State.COMMENT_END:\n        {\n          this._stateCommentEnd(cp);\n          break;\n        }\n      case State.COMMENT_END_BANG:\n        {\n          this._stateCommentEndBang(cp);\n          break;\n        }\n      case State.DOCTYPE:\n        {\n          this._stateDoctype(cp);\n          break;\n        }\n      case State.BEFORE_DOCTYPE_NAME:\n        {\n          this._stateBeforeDoctypeName(cp);\n          break;\n        }\n      case State.DOCTYPE_NAME:\n        {\n          this._stateDoctypeName(cp);\n          break;\n        }\n      case State.AFTER_DOCTYPE_NAME:\n        {\n          this._stateAfterDoctypeName(cp);\n          break;\n        }\n      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD:\n        {\n          this._stateAfterDoctypePublicKeyword(cp);\n          break;\n        }\n      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:\n        {\n          this._stateBeforeDoctypePublicIdentifier(cp);\n          break;\n        }\n      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:\n        {\n          this._stateDoctypePublicIdentifierDoubleQuoted(cp);\n          break;\n        }\n      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:\n        {\n          this._stateDoctypePublicIdentifierSingleQuoted(cp);\n          break;\n        }\n      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER:\n        {\n          this._stateAfterDoctypePublicIdentifier(cp);\n          break;\n        }\n      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:\n        {\n          this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);\n          break;\n        }\n      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD:\n        {\n          this._stateAfterDoctypeSystemKeyword(cp);\n          break;\n        }\n      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:\n        {\n          this._stateBeforeDoctypeSystemIdentifier(cp);\n          break;\n        }\n      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:\n        {\n          this._stateDoctypeSystemIdentifierDoubleQuoted(cp);\n          break;\n        }\n      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:\n        {\n          this._stateDoctypeSystemIdentifierSingleQuoted(cp);\n          break;\n        }\n      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER:\n        {\n          this._stateAfterDoctypeSystemIdentifier(cp);\n          break;\n        }\n      case State.BOGUS_DOCTYPE:\n        {\n          this._stateBogusDoctype(cp);\n          break;\n        }\n      case State.CDATA_SECTION:\n        {\n          this._stateCdataSection(cp);\n          break;\n        }\n      case State.CDATA_SECTION_BRACKET:\n        {\n          this._stateCdataSectionBracket(cp);\n          break;\n        }\n      case State.CDATA_SECTION_END:\n        {\n          this._stateCdataSectionEnd(cp);\n          break;\n        }\n      case State.CHARACTER_REFERENCE:\n        {\n          this._stateCharacterReference(cp);\n          break;\n        }\n      case State.NAMED_CHARACTER_REFERENCE:\n        {\n          this._stateNamedCharacterReference(cp);\n          break;\n        }\n      case State.AMBIGUOUS_AMPERSAND:\n        {\n          this._stateAmbiguousAmpersand(cp);\n          break;\n        }\n      case State.NUMERIC_CHARACTER_REFERENCE:\n        {\n          this._stateNumericCharacterReference(cp);\n          break;\n        }\n      case State.HEXADEMICAL_CHARACTER_REFERENCE_START:\n        {\n          this._stateHexademicalCharacterReferenceStart(cp);\n          break;\n        }\n      case State.HEXADEMICAL_CHARACTER_REFERENCE:\n        {\n          this._stateHexademicalCharacterReference(cp);\n          break;\n        }\n      case State.DECIMAL_CHARACTER_REFERENCE:\n        {\n          this._stateDecimalCharacterReference(cp);\n          break;\n        }\n      case State.NUMERIC_CHARACTER_REFERENCE_END:\n        {\n          this._stateNumericCharacterReferenceEnd(cp);\n          break;\n        }\n      default:\n        {\n          throw new Error('Unknown state');\n        }\n    }\n  }\n  // State machine\n  // Data state\n  //------------------------------------------------------------------\n  _stateData(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this.state = State.TAG_OPEN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.AMPERSAND:\n        {\n          this.returnState = State.DATA;\n          this.state = State.CHARACTER_REFERENCE;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this._emitCodePoint(cp);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  //  RCDATA state\n  //------------------------------------------------------------------\n  _stateRcdata(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.AMPERSAND:\n        {\n          this.returnState = State.RCDATA;\n          this.state = State.CHARACTER_REFERENCE;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this.state = State.RCDATA_LESS_THAN_SIGN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // RAWTEXT state\n  //------------------------------------------------------------------\n  _stateRawtext(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this.state = State.RAWTEXT_LESS_THAN_SIGN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // Script data state\n  //------------------------------------------------------------------\n  _stateScriptData(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // PLAINTEXT state\n  //------------------------------------------------------------------\n  _statePlaintext(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // Tag open state\n  //------------------------------------------------------------------\n  _stateTagOpen(cp) {\n    if (isAsciiLetter(cp)) {\n      this._createStartTagToken();\n      this.state = State.TAG_NAME;\n      this._stateTagName(cp);\n    } else switch (cp) {\n      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK:\n        {\n          this.state = State.MARKUP_DECLARATION_OPEN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.SOLIDUS:\n        {\n          this.state = State.END_TAG_OPEN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.QUESTION_MARK:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedQuestionMarkInsteadOfTagName);\n          this._createCommentToken(1);\n          this.state = State.BOGUS_COMMENT;\n          this._stateBogusComment(cp);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofBeforeTagName);\n          this._emitChars('<');\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.invalidFirstCharacterOfTagName);\n          this._emitChars('<');\n          this.state = State.DATA;\n          this._stateData(cp);\n        }\n    }\n  }\n  // End tag open state\n  //------------------------------------------------------------------\n  _stateEndTagOpen(cp) {\n    if (isAsciiLetter(cp)) {\n      this._createEndTagToken();\n      this.state = State.TAG_NAME;\n      this._stateTagName(cp);\n    } else switch (cp) {\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.missingEndTagName);\n          this.state = State.DATA;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofBeforeTagName);\n          this._emitChars('</');\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.invalidFirstCharacterOfTagName);\n          this._createCommentToken(2);\n          this.state = State.BOGUS_COMMENT;\n          this._stateBogusComment(cp);\n        }\n    }\n  }\n  // Tag name state\n  //------------------------------------------------------------------\n  _stateTagName(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.SOLIDUS:\n        {\n          this.state = State.SELF_CLOSING_START_TAG;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.DATA;\n          this.emitCurrentTagToken();\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          token.tagName += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInTag);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);\n        }\n    }\n  }\n  // RCDATA less-than sign state\n  //------------------------------------------------------------------\n  _stateRcdataLessThanSign(cp) {\n    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {\n      this.state = State.RCDATA_END_TAG_OPEN;\n    } else {\n      this._emitChars('<');\n      this.state = State.RCDATA;\n      this._stateRcdata(cp);\n    }\n  }\n  // RCDATA end tag open state\n  //------------------------------------------------------------------\n  _stateRcdataEndTagOpen(cp) {\n    if (isAsciiLetter(cp)) {\n      this.state = State.RCDATA_END_TAG_NAME;\n      this._stateRcdataEndTagName(cp);\n    } else {\n      this._emitChars('</');\n      this.state = State.RCDATA;\n      this._stateRcdata(cp);\n    }\n  }\n  handleSpecialEndTag(_cp) {\n    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {\n      return !this._ensureHibernation();\n    }\n    this._createEndTagToken();\n    const token = this.currentToken;\n    token.tagName = this.lastStartTagName;\n    const cp = this.preprocessor.peek(this.lastStartTagName.length);\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          this._advanceBy(this.lastStartTagName.length);\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n          return false;\n        }\n      case unicode_js_1.CODE_POINTS.SOLIDUS:\n        {\n          this._advanceBy(this.lastStartTagName.length);\n          this.state = State.SELF_CLOSING_START_TAG;\n          return false;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._advanceBy(this.lastStartTagName.length);\n          this.emitCurrentTagToken();\n          this.state = State.DATA;\n          return false;\n        }\n      default:\n        {\n          return !this._ensureHibernation();\n        }\n    }\n  }\n  // RCDATA end tag name state\n  //------------------------------------------------------------------\n  _stateRcdataEndTagName(cp) {\n    if (this.handleSpecialEndTag(cp)) {\n      this._emitChars('</');\n      this.state = State.RCDATA;\n      this._stateRcdata(cp);\n    }\n  }\n  // RAWTEXT less-than sign state\n  //------------------------------------------------------------------\n  _stateRawtextLessThanSign(cp) {\n    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {\n      this.state = State.RAWTEXT_END_TAG_OPEN;\n    } else {\n      this._emitChars('<');\n      this.state = State.RAWTEXT;\n      this._stateRawtext(cp);\n    }\n  }\n  // RAWTEXT end tag open state\n  //------------------------------------------------------------------\n  _stateRawtextEndTagOpen(cp) {\n    if (isAsciiLetter(cp)) {\n      this.state = State.RAWTEXT_END_TAG_NAME;\n      this._stateRawtextEndTagName(cp);\n    } else {\n      this._emitChars('</');\n      this.state = State.RAWTEXT;\n      this._stateRawtext(cp);\n    }\n  }\n  // RAWTEXT end tag name state\n  //------------------------------------------------------------------\n  _stateRawtextEndTagName(cp) {\n    if (this.handleSpecialEndTag(cp)) {\n      this._emitChars('</');\n      this.state = State.RAWTEXT;\n      this._stateRawtext(cp);\n    }\n  }\n  // Script data less-than sign state\n  //------------------------------------------------------------------\n  _stateScriptDataLessThanSign(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SOLIDUS:\n        {\n          this.state = State.SCRIPT_DATA_END_TAG_OPEN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK:\n        {\n          this.state = State.SCRIPT_DATA_ESCAPE_START;\n          this._emitChars('<!');\n          break;\n        }\n      default:\n        {\n          this._emitChars('<');\n          this.state = State.SCRIPT_DATA;\n          this._stateScriptData(cp);\n        }\n    }\n  }\n  // Script data end tag open state\n  //------------------------------------------------------------------\n  _stateScriptDataEndTagOpen(cp) {\n    if (isAsciiLetter(cp)) {\n      this.state = State.SCRIPT_DATA_END_TAG_NAME;\n      this._stateScriptDataEndTagName(cp);\n    } else {\n      this._emitChars('</');\n      this.state = State.SCRIPT_DATA;\n      this._stateScriptData(cp);\n    }\n  }\n  // Script data end tag name state\n  //------------------------------------------------------------------\n  _stateScriptDataEndTagName(cp) {\n    if (this.handleSpecialEndTag(cp)) {\n      this._emitChars('</');\n      this.state = State.SCRIPT_DATA;\n      this._stateScriptData(cp);\n    }\n  }\n  // Script data escape start state\n  //------------------------------------------------------------------\n  _stateScriptDataEscapeStart(cp) {\n    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {\n      this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;\n      this._emitChars('-');\n    } else {\n      this.state = State.SCRIPT_DATA;\n      this._stateScriptData(cp);\n    }\n  }\n  // Script data escape start dash state\n  //------------------------------------------------------------------\n  _stateScriptDataEscapeStartDash(cp) {\n    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {\n      this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;\n      this._emitChars('-');\n    } else {\n      this.state = State.SCRIPT_DATA;\n      this._stateScriptData(cp);\n    }\n  }\n  // Script data escaped state\n  //------------------------------------------------------------------\n  _stateScriptDataEscaped(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          this.state = State.SCRIPT_DATA_ESCAPED_DASH;\n          this._emitChars('-');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // Script data escaped dash state\n  //------------------------------------------------------------------\n  _stateScriptDataEscapedDash(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;\n          this._emitChars('-');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this.state = State.SCRIPT_DATA_ESCAPED;\n          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this.state = State.SCRIPT_DATA_ESCAPED;\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // Script data escaped dash dash state\n  //------------------------------------------------------------------\n  _stateScriptDataEscapedDashDash(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          this._emitChars('-');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.SCRIPT_DATA;\n          this._emitChars('>');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this.state = State.SCRIPT_DATA_ESCAPED;\n          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this.state = State.SCRIPT_DATA_ESCAPED;\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // Script data escaped less-than sign state\n  //------------------------------------------------------------------\n  _stateScriptDataEscapedLessThanSign(cp) {\n    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {\n      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;\n    } else if (isAsciiLetter(cp)) {\n      this._emitChars('<');\n      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;\n      this._stateScriptDataDoubleEscapeStart(cp);\n    } else {\n      this._emitChars('<');\n      this.state = State.SCRIPT_DATA_ESCAPED;\n      this._stateScriptDataEscaped(cp);\n    }\n  }\n  // Script data escaped end tag open state\n  //------------------------------------------------------------------\n  _stateScriptDataEscapedEndTagOpen(cp) {\n    if (isAsciiLetter(cp)) {\n      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;\n      this._stateScriptDataEscapedEndTagName(cp);\n    } else {\n      this._emitChars('</');\n      this.state = State.SCRIPT_DATA_ESCAPED;\n      this._stateScriptDataEscaped(cp);\n    }\n  }\n  // Script data escaped end tag name state\n  //------------------------------------------------------------------\n  _stateScriptDataEscapedEndTagName(cp) {\n    if (this.handleSpecialEndTag(cp)) {\n      this._emitChars('</');\n      this.state = State.SCRIPT_DATA_ESCAPED;\n      this._stateScriptDataEscaped(cp);\n    }\n  }\n  // Script data double escape start state\n  //------------------------------------------------------------------\n  _stateScriptDataDoubleEscapeStart(cp) {\n    if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {\n      this._emitCodePoint(cp);\n      for (let i = 0; i < unicode_js_1.SEQUENCES.SCRIPT.length; i++) {\n        this._emitCodePoint(this._consume());\n      }\n      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n    } else if (!this._ensureHibernation()) {\n      this.state = State.SCRIPT_DATA_ESCAPED;\n      this._stateScriptDataEscaped(cp);\n    }\n  }\n  // Script data double escaped state\n  //------------------------------------------------------------------\n  _stateScriptDataDoubleEscaped(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;\n          this._emitChars('-');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;\n          this._emitChars('<');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // Script data double escaped dash state\n  //------------------------------------------------------------------\n  _stateScriptDataDoubleEscapedDash(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;\n          this._emitChars('-');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;\n          this._emitChars('<');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // Script data double escaped dash dash state\n  //------------------------------------------------------------------\n  _stateScriptDataDoubleEscapedDashDash(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          this._emitChars('-');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;\n          this._emitChars('<');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.SCRIPT_DATA;\n          this._emitChars('>');\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // Script data double escaped less-than sign state\n  //------------------------------------------------------------------\n  _stateScriptDataDoubleEscapedLessThanSign(cp) {\n    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {\n      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;\n      this._emitChars('/');\n    } else {\n      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n      this._stateScriptDataDoubleEscaped(cp);\n    }\n  }\n  // Script data double escape end state\n  //------------------------------------------------------------------\n  _stateScriptDataDoubleEscapeEnd(cp) {\n    if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {\n      this._emitCodePoint(cp);\n      for (let i = 0; i < unicode_js_1.SEQUENCES.SCRIPT.length; i++) {\n        this._emitCodePoint(this._consume());\n      }\n      this.state = State.SCRIPT_DATA_ESCAPED;\n    } else if (!this._ensureHibernation()) {\n      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n      this._stateScriptDataDoubleEscaped(cp);\n    }\n  }\n  // Before attribute name state\n  //------------------------------------------------------------------\n  _stateBeforeAttributeName(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          // Ignore whitespace\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.SOLIDUS:\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this.state = State.AFTER_ATTRIBUTE_NAME;\n          this._stateAfterAttributeName(cp);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EQUALS_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedEqualsSignBeforeAttributeName);\n          this._createAttr('=');\n          this.state = State.ATTRIBUTE_NAME;\n          break;\n        }\n      default:\n        {\n          this._createAttr('');\n          this.state = State.ATTRIBUTE_NAME;\n          this._stateAttributeName(cp);\n        }\n    }\n  }\n  // Attribute name state\n  //------------------------------------------------------------------\n  _stateAttributeName(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n      case unicode_js_1.CODE_POINTS.SOLIDUS:\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._leaveAttrName();\n          this.state = State.AFTER_ATTRIBUTE_NAME;\n          this._stateAfterAttributeName(cp);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EQUALS_SIGN:\n        {\n          this._leaveAttrName();\n          this.state = State.BEFORE_ATTRIBUTE_VALUE;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedCharacterInAttributeName);\n          this.currentAttr.name += String.fromCodePoint(cp);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this.currentAttr.name += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      default:\n        {\n          this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);\n        }\n    }\n  }\n  // After attribute name state\n  //------------------------------------------------------------------\n  _stateAfterAttributeName(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          // Ignore whitespace\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.SOLIDUS:\n        {\n          this.state = State.SELF_CLOSING_START_TAG;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EQUALS_SIGN:\n        {\n          this.state = State.BEFORE_ATTRIBUTE_VALUE;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.DATA;\n          this.emitCurrentTagToken();\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInTag);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._createAttr('');\n          this.state = State.ATTRIBUTE_NAME;\n          this._stateAttributeName(cp);\n        }\n    }\n  }\n  // Before attribute value state\n  //------------------------------------------------------------------\n  _stateBeforeAttributeValue(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          // Ignore whitespace\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n        {\n          this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n        {\n          this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.missingAttributeValue);\n          this.state = State.DATA;\n          this.emitCurrentTagToken();\n          break;\n        }\n      default:\n        {\n          this.state = State.ATTRIBUTE_VALUE_UNQUOTED;\n          this._stateAttributeValueUnquoted(cp);\n        }\n    }\n  }\n  // Attribute value (double-quoted) state\n  //------------------------------------------------------------------\n  _stateAttributeValueDoubleQuoted(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n        {\n          this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.AMPERSAND:\n        {\n          this.returnState = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;\n          this.state = State.CHARACTER_REFERENCE;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInTag);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this.currentAttr.value += String.fromCodePoint(cp);\n        }\n    }\n  }\n  // Attribute value (single-quoted) state\n  //------------------------------------------------------------------\n  _stateAttributeValueSingleQuoted(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n        {\n          this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.AMPERSAND:\n        {\n          this.returnState = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;\n          this.state = State.CHARACTER_REFERENCE;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInTag);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this.currentAttr.value += String.fromCodePoint(cp);\n        }\n    }\n  }\n  // Attribute value (unquoted) state\n  //------------------------------------------------------------------\n  _stateAttributeValueUnquoted(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          this._leaveAttrValue();\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.AMPERSAND:\n        {\n          this.returnState = State.ATTRIBUTE_VALUE_UNQUOTED;\n          this.state = State.CHARACTER_REFERENCE;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._leaveAttrValue();\n          this.state = State.DATA;\n          this.emitCurrentTagToken();\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n      case unicode_js_1.CODE_POINTS.EQUALS_SIGN:\n      case unicode_js_1.CODE_POINTS.GRAVE_ACCENT:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedCharacterInUnquotedAttributeValue);\n          this.currentAttr.value += String.fromCodePoint(cp);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInTag);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this.currentAttr.value += String.fromCodePoint(cp);\n        }\n    }\n  }\n  // After attribute value (quoted) state\n  //------------------------------------------------------------------\n  _stateAfterAttributeValueQuoted(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          this._leaveAttrValue();\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.SOLIDUS:\n        {\n          this._leaveAttrValue();\n          this.state = State.SELF_CLOSING_START_TAG;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._leaveAttrValue();\n          this.state = State.DATA;\n          this.emitCurrentTagToken();\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInTag);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.missingWhitespaceBetweenAttributes);\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n          this._stateBeforeAttributeName(cp);\n        }\n    }\n  }\n  // Self-closing start tag state\n  //------------------------------------------------------------------\n  _stateSelfClosingStartTag(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          const token = this.currentToken;\n          token.selfClosing = true;\n          this.state = State.DATA;\n          this.emitCurrentTagToken();\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInTag);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedSolidusInTag);\n          this.state = State.BEFORE_ATTRIBUTE_NAME;\n          this._stateBeforeAttributeName(cp);\n        }\n    }\n  }\n  // Bogus comment state\n  //------------------------------------------------------------------\n  _stateBogusComment(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.DATA;\n          this.emitCurrentComment(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this.emitCurrentComment(token);\n          this._emitEOFToken();\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          token.data += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      default:\n        {\n          token.data += String.fromCodePoint(cp);\n        }\n    }\n  }\n  // Markup declaration open state\n  //------------------------------------------------------------------\n  _stateMarkupDeclarationOpen(cp) {\n    if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DASH_DASH, true)) {\n      this._createCommentToken(unicode_js_1.SEQUENCES.DASH_DASH.length + 1);\n      this.state = State.COMMENT_START;\n    } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DOCTYPE, false)) {\n      // NOTE: Doctypes tokens are created without fixed offsets. We keep track of the moment a doctype *might* start here.\n      this.currentLocation = this.getCurrentLocation(unicode_js_1.SEQUENCES.DOCTYPE.length + 1);\n      this.state = State.DOCTYPE;\n    } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.CDATA_START, true)) {\n      if (this.inForeignNode) {\n        this.state = State.CDATA_SECTION;\n      } else {\n        this._err(error_codes_js_1.ERR.cdataInHtmlContent);\n        this._createCommentToken(unicode_js_1.SEQUENCES.CDATA_START.length + 1);\n        this.currentToken.data = '[CDATA[';\n        this.state = State.BOGUS_COMMENT;\n      }\n    }\n    //NOTE: Sequence lookups can be abrupted by hibernation. In that case, lookup\n    //results are no longer valid and we will need to start over.\n    else if (!this._ensureHibernation()) {\n      this._err(error_codes_js_1.ERR.incorrectlyOpenedComment);\n      this._createCommentToken(2);\n      this.state = State.BOGUS_COMMENT;\n      this._stateBogusComment(cp);\n    }\n  }\n  // Comment start state\n  //------------------------------------------------------------------\n  _stateCommentStart(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          this.state = State.COMMENT_START_DASH;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.abruptClosingOfEmptyComment);\n          this.state = State.DATA;\n          const token = this.currentToken;\n          this.emitCurrentComment(token);\n          break;\n        }\n      default:\n        {\n          this.state = State.COMMENT;\n          this._stateComment(cp);\n        }\n    }\n  }\n  // Comment start dash state\n  //------------------------------------------------------------------\n  _stateCommentStartDash(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          this.state = State.COMMENT_END;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.abruptClosingOfEmptyComment);\n          this.state = State.DATA;\n          this.emitCurrentComment(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInComment);\n          this.emitCurrentComment(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.data += '-';\n          this.state = State.COMMENT;\n          this._stateComment(cp);\n        }\n    }\n  }\n  // Comment state\n  //------------------------------------------------------------------\n  _stateComment(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          this.state = State.COMMENT_END_DASH;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          token.data += '<';\n          this.state = State.COMMENT_LESS_THAN_SIGN;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          token.data += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInComment);\n          this.emitCurrentComment(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.data += String.fromCodePoint(cp);\n        }\n    }\n  }\n  // Comment less-than sign state\n  //------------------------------------------------------------------\n  _stateCommentLessThanSign(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK:\n        {\n          token.data += '!';\n          this.state = State.COMMENT_LESS_THAN_SIGN_BANG;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:\n        {\n          token.data += '<';\n          break;\n        }\n      default:\n        {\n          this.state = State.COMMENT;\n          this._stateComment(cp);\n        }\n    }\n  }\n  // Comment less-than sign bang state\n  //------------------------------------------------------------------\n  _stateCommentLessThanSignBang(cp) {\n    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {\n      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;\n    } else {\n      this.state = State.COMMENT;\n      this._stateComment(cp);\n    }\n  }\n  // Comment less-than sign bang dash state\n  //------------------------------------------------------------------\n  _stateCommentLessThanSignBangDash(cp) {\n    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {\n      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;\n    } else {\n      this.state = State.COMMENT_END_DASH;\n      this._stateCommentEndDash(cp);\n    }\n  }\n  // Comment less-than sign bang dash dash state\n  //------------------------------------------------------------------\n  _stateCommentLessThanSignBangDashDash(cp) {\n    if (cp !== unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN && cp !== unicode_js_1.CODE_POINTS.EOF) {\n      this._err(error_codes_js_1.ERR.nestedComment);\n    }\n    this.state = State.COMMENT_END;\n    this._stateCommentEnd(cp);\n  }\n  // Comment end dash state\n  //------------------------------------------------------------------\n  _stateCommentEndDash(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          this.state = State.COMMENT_END;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInComment);\n          this.emitCurrentComment(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.data += '-';\n          this.state = State.COMMENT;\n          this._stateComment(cp);\n        }\n    }\n  }\n  // Comment end state\n  //------------------------------------------------------------------\n  _stateCommentEnd(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.DATA;\n          this.emitCurrentComment(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK:\n        {\n          this.state = State.COMMENT_END_BANG;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          token.data += '-';\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInComment);\n          this.emitCurrentComment(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.data += '--';\n          this.state = State.COMMENT;\n          this._stateComment(cp);\n        }\n    }\n  }\n  // Comment end bang state\n  //------------------------------------------------------------------\n  _stateCommentEndBang(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:\n        {\n          token.data += '--!';\n          this.state = State.COMMENT_END_DASH;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.incorrectlyClosedComment);\n          this.state = State.DATA;\n          this.emitCurrentComment(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInComment);\n          this.emitCurrentComment(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.data += '--!';\n          this.state = State.COMMENT;\n          this._stateComment(cp);\n        }\n    }\n  }\n  // DOCTYPE state\n  //------------------------------------------------------------------\n  _stateDoctype(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          this.state = State.BEFORE_DOCTYPE_NAME;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.BEFORE_DOCTYPE_NAME;\n          this._stateBeforeDoctypeName(cp);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          this._createDoctypeToken(null);\n          const token = this.currentToken;\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.missingWhitespaceBeforeDoctypeName);\n          this.state = State.BEFORE_DOCTYPE_NAME;\n          this._stateBeforeDoctypeName(cp);\n        }\n    }\n  }\n  // Before DOCTYPE name state\n  //------------------------------------------------------------------\n  _stateBeforeDoctypeName(cp) {\n    if (isAsciiUpper(cp)) {\n      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));\n      this.state = State.DOCTYPE_NAME;\n    } else switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          // Ignore whitespace\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          this._createDoctypeToken(unicode_js_1.REPLACEMENT_CHARACTER);\n          this.state = State.DOCTYPE_NAME;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.missingDoctypeName);\n          this._createDoctypeToken(null);\n          const token = this.currentToken;\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this.state = State.DATA;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          this._createDoctypeToken(null);\n          const token = this.currentToken;\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._createDoctypeToken(String.fromCodePoint(cp));\n          this.state = State.DOCTYPE_NAME;\n        }\n    }\n  }\n  // DOCTYPE name state\n  //------------------------------------------------------------------\n  _stateDoctypeName(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          this.state = State.AFTER_DOCTYPE_NAME;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.DATA;\n          this.emitCurrentDoctype(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          token.name += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);\n        }\n    }\n  }\n  // After DOCTYPE name state\n  //------------------------------------------------------------------\n  _stateAfterDoctypeName(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          // Ignore whitespace\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.DATA;\n          this.emitCurrentDoctype(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.PUBLIC, false)) {\n          this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;\n        } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.SYSTEM, false)) {\n          this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;\n        }\n        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup\n        //results are no longer valid and we will need to start over.\n        else if (!this._ensureHibernation()) {\n          this._err(error_codes_js_1.ERR.invalidCharacterSequenceAfterDoctypeName);\n          token.forceQuirks = true;\n          this.state = State.BOGUS_DOCTYPE;\n          this._stateBogusDoctype(cp);\n        }\n    }\n  }\n  // After DOCTYPE public keyword state\n  //------------------------------------------------------------------\n  _stateAfterDoctypePublicKeyword(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n        {\n          this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypePublicKeyword);\n          token.publicId = '';\n          this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n        {\n          this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypePublicKeyword);\n          token.publicId = '';\n          this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.missingDoctypePublicIdentifier);\n          token.forceQuirks = true;\n          this.state = State.DATA;\n          this.emitCurrentDoctype(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypePublicIdentifier);\n          token.forceQuirks = true;\n          this.state = State.BOGUS_DOCTYPE;\n          this._stateBogusDoctype(cp);\n        }\n    }\n  }\n  // Before DOCTYPE public identifier state\n  //------------------------------------------------------------------\n  _stateBeforeDoctypePublicIdentifier(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          // Ignore whitespace\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n        {\n          token.publicId = '';\n          this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n        {\n          token.publicId = '';\n          this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.missingDoctypePublicIdentifier);\n          token.forceQuirks = true;\n          this.state = State.DATA;\n          this.emitCurrentDoctype(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypePublicIdentifier);\n          token.forceQuirks = true;\n          this.state = State.BOGUS_DOCTYPE;\n          this._stateBogusDoctype(cp);\n        }\n    }\n  }\n  // DOCTYPE public identifier (double-quoted) state\n  //------------------------------------------------------------------\n  _stateDoctypePublicIdentifierDoubleQuoted(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n        {\n          this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          token.publicId += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.abruptDoctypePublicIdentifier);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this.state = State.DATA;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.publicId += String.fromCodePoint(cp);\n        }\n    }\n  }\n  // DOCTYPE public identifier (single-quoted) state\n  //------------------------------------------------------------------\n  _stateDoctypePublicIdentifierSingleQuoted(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n        {\n          this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          token.publicId += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.abruptDoctypePublicIdentifier);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this.state = State.DATA;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.publicId += String.fromCodePoint(cp);\n        }\n    }\n  }\n  // After DOCTYPE public identifier state\n  //------------------------------------------------------------------\n  _stateAfterDoctypePublicIdentifier(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.DATA;\n          this.emitCurrentDoctype(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n        {\n          this._err(error_codes_js_1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);\n          token.systemId = '';\n          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n        {\n          this._err(error_codes_js_1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);\n          token.systemId = '';\n          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n          token.forceQuirks = true;\n          this.state = State.BOGUS_DOCTYPE;\n          this._stateBogusDoctype(cp);\n        }\n    }\n  }\n  // Between DOCTYPE public and system identifiers state\n  //------------------------------------------------------------------\n  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          // Ignore whitespace\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.emitCurrentDoctype(token);\n          this.state = State.DATA;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n        {\n          token.systemId = '';\n          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n        {\n          token.systemId = '';\n          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n          token.forceQuirks = true;\n          this.state = State.BOGUS_DOCTYPE;\n          this._stateBogusDoctype(cp);\n        }\n    }\n  }\n  // After DOCTYPE system keyword state\n  //------------------------------------------------------------------\n  _stateAfterDoctypeSystemKeyword(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n        {\n          this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);\n          token.systemId = '';\n          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n        {\n          this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);\n          token.systemId = '';\n          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.missingDoctypeSystemIdentifier);\n          token.forceQuirks = true;\n          this.state = State.DATA;\n          this.emitCurrentDoctype(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n          token.forceQuirks = true;\n          this.state = State.BOGUS_DOCTYPE;\n          this._stateBogusDoctype(cp);\n        }\n    }\n  }\n  // Before DOCTYPE system identifier state\n  //------------------------------------------------------------------\n  _stateBeforeDoctypeSystemIdentifier(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          // Ignore whitespace\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n        {\n          token.systemId = '';\n          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n        {\n          token.systemId = '';\n          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.missingDoctypeSystemIdentifier);\n          token.forceQuirks = true;\n          this.state = State.DATA;\n          this.emitCurrentDoctype(token);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n          token.forceQuirks = true;\n          this.state = State.BOGUS_DOCTYPE;\n          this._stateBogusDoctype(cp);\n        }\n    }\n  }\n  // DOCTYPE system identifier (double-quoted) state\n  //------------------------------------------------------------------\n  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:\n        {\n          this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          token.systemId += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.abruptDoctypeSystemIdentifier);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this.state = State.DATA;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.systemId += String.fromCodePoint(cp);\n        }\n    }\n  }\n  // DOCTYPE system identifier (single-quoted) state\n  //------------------------------------------------------------------\n  _stateDoctypeSystemIdentifierSingleQuoted(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.APOSTROPHE:\n        {\n          this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          token.systemId += unicode_js_1.REPLACEMENT_CHARACTER;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this._err(error_codes_js_1.ERR.abruptDoctypeSystemIdentifier);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this.state = State.DATA;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          token.systemId += String.fromCodePoint(cp);\n        }\n    }\n  }\n  // After DOCTYPE system identifier state\n  //------------------------------------------------------------------\n  _stateAfterDoctypeSystemIdentifier(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.SPACE:\n      case unicode_js_1.CODE_POINTS.LINE_FEED:\n      case unicode_js_1.CODE_POINTS.TABULATION:\n      case unicode_js_1.CODE_POINTS.FORM_FEED:\n        {\n          // Ignore whitespace\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.emitCurrentDoctype(token);\n          this.state = State.DATA;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInDoctype);\n          token.forceQuirks = true;\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);\n          this.state = State.BOGUS_DOCTYPE;\n          this._stateBogusDoctype(cp);\n        }\n    }\n  }\n  // Bogus DOCTYPE state\n  //------------------------------------------------------------------\n  _stateBogusDoctype(cp) {\n    const token = this.currentToken;\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.emitCurrentDoctype(token);\n          this.state = State.DATA;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.NULL:\n        {\n          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this.emitCurrentDoctype(token);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n      // Do nothing\n    }\n  }\n  // CDATA section state\n  //------------------------------------------------------------------\n  _stateCdataSection(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET:\n        {\n          this.state = State.CDATA_SECTION_BRACKET;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.EOF:\n        {\n          this._err(error_codes_js_1.ERR.eofInCdata);\n          this._emitEOFToken();\n          break;\n        }\n      default:\n        {\n          this._emitCodePoint(cp);\n        }\n    }\n  }\n  // CDATA section bracket state\n  //------------------------------------------------------------------\n  _stateCdataSectionBracket(cp) {\n    if (cp === unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET) {\n      this.state = State.CDATA_SECTION_END;\n    } else {\n      this._emitChars(']');\n      this.state = State.CDATA_SECTION;\n      this._stateCdataSection(cp);\n    }\n  }\n  // CDATA section end state\n  //------------------------------------------------------------------\n  _stateCdataSectionEnd(cp) {\n    switch (cp) {\n      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:\n        {\n          this.state = State.DATA;\n          break;\n        }\n      case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET:\n        {\n          this._emitChars(']');\n          break;\n        }\n      default:\n        {\n          this._emitChars(']]');\n          this.state = State.CDATA_SECTION;\n          this._stateCdataSection(cp);\n        }\n    }\n  }\n  // Character reference state\n  //------------------------------------------------------------------\n  _stateCharacterReference(cp) {\n    if (cp === unicode_js_1.CODE_POINTS.NUMBER_SIGN) {\n      this.state = State.NUMERIC_CHARACTER_REFERENCE;\n    } else if (isAsciiAlphaNumeric(cp)) {\n      this.state = State.NAMED_CHARACTER_REFERENCE;\n      this._stateNamedCharacterReference(cp);\n    } else {\n      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);\n      this._reconsumeInState(this.returnState, cp);\n    }\n  }\n  // Named character reference state\n  //------------------------------------------------------------------\n  _stateNamedCharacterReference(cp) {\n    const matchResult = this._matchNamedCharacterReference(cp);\n    //NOTE: Matching can be abrupted by hibernation. In that case, match\n    //results are no longer valid and we will need to start over.\n    if (this._ensureHibernation()) {\n      // Stay in the state, try again.\n    } else if (matchResult) {\n      for (let i = 0; i < matchResult.length; i++) {\n        this._flushCodePointConsumedAsCharacterReference(matchResult[i]);\n      }\n      this.state = this.returnState;\n    } else {\n      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);\n      this.state = State.AMBIGUOUS_AMPERSAND;\n    }\n  }\n  // Ambiguos ampersand state\n  //------------------------------------------------------------------\n  _stateAmbiguousAmpersand(cp) {\n    if (isAsciiAlphaNumeric(cp)) {\n      this._flushCodePointConsumedAsCharacterReference(cp);\n    } else {\n      if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {\n        this._err(error_codes_js_1.ERR.unknownNamedCharacterReference);\n      }\n      this._reconsumeInState(this.returnState, cp);\n    }\n  }\n  // Numeric character reference state\n  //------------------------------------------------------------------\n  _stateNumericCharacterReference(cp) {\n    this.charRefCode = 0;\n    if (cp === unicode_js_1.CODE_POINTS.LATIN_SMALL_X || cp === unicode_js_1.CODE_POINTS.LATIN_CAPITAL_X) {\n      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE_START;\n    }\n    // Inlined decimal character reference start state\n    else if (isAsciiDigit(cp)) {\n      this.state = State.DECIMAL_CHARACTER_REFERENCE;\n      this._stateDecimalCharacterReference(cp);\n    } else {\n      this._err(error_codes_js_1.ERR.absenceOfDigitsInNumericCharacterReference);\n      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);\n      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.NUMBER_SIGN);\n      this._reconsumeInState(this.returnState, cp);\n    }\n  }\n  // Hexademical character reference start state\n  //------------------------------------------------------------------\n  _stateHexademicalCharacterReferenceStart(cp) {\n    if (isAsciiHexDigit(cp)) {\n      this.state = State.HEXADEMICAL_CHARACTER_REFERENCE;\n      this._stateHexademicalCharacterReference(cp);\n    } else {\n      this._err(error_codes_js_1.ERR.absenceOfDigitsInNumericCharacterReference);\n      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);\n      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.NUMBER_SIGN);\n      this._unconsume(2);\n      this.state = this.returnState;\n    }\n  }\n  // Hexademical character reference state\n  //------------------------------------------------------------------\n  _stateHexademicalCharacterReference(cp) {\n    if (isAsciiUpperHexDigit(cp)) {\n      this.charRefCode = this.charRefCode * 16 + cp - 0x37;\n    } else if (isAsciiLowerHexDigit(cp)) {\n      this.charRefCode = this.charRefCode * 16 + cp - 0x57;\n    } else if (isAsciiDigit(cp)) {\n      this.charRefCode = this.charRefCode * 16 + cp - 0x30;\n    } else if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {\n      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;\n    } else {\n      this._err(error_codes_js_1.ERR.missingSemicolonAfterCharacterReference);\n      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;\n      this._stateNumericCharacterReferenceEnd(cp);\n    }\n  }\n  // Decimal character reference state\n  //------------------------------------------------------------------\n  _stateDecimalCharacterReference(cp) {\n    if (isAsciiDigit(cp)) {\n      this.charRefCode = this.charRefCode * 10 + cp - 0x30;\n    } else if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {\n      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;\n    } else {\n      this._err(error_codes_js_1.ERR.missingSemicolonAfterCharacterReference);\n      this.state = State.NUMERIC_CHARACTER_REFERENCE_END;\n      this._stateNumericCharacterReferenceEnd(cp);\n    }\n  }\n  // Numeric character reference end state\n  //------------------------------------------------------------------\n  _stateNumericCharacterReferenceEnd(cp) {\n    if (this.charRefCode === unicode_js_1.CODE_POINTS.NULL) {\n      this._err(error_codes_js_1.ERR.nullCharacterReference);\n      this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;\n    } else if (this.charRefCode > 1114111) {\n      this._err(error_codes_js_1.ERR.characterReferenceOutsideUnicodeRange);\n      this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;\n    } else if ((0, unicode_js_1.isSurrogate)(this.charRefCode)) {\n      this._err(error_codes_js_1.ERR.surrogateCharacterReference);\n      this.charRefCode = unicode_js_1.CODE_POINTS.REPLACEMENT_CHARACTER;\n    } else if ((0, unicode_js_1.isUndefinedCodePoint)(this.charRefCode)) {\n      this._err(error_codes_js_1.ERR.noncharacterCharacterReference);\n    } else if ((0, unicode_js_1.isControlCodePoint)(this.charRefCode) || this.charRefCode === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {\n      this._err(error_codes_js_1.ERR.controlCharacterReference);\n      const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);\n      if (replacement !== undefined) {\n        this.charRefCode = replacement;\n      }\n    }\n    this._flushCodePointConsumedAsCharacterReference(this.charRefCode);\n    this._reconsumeInState(this.returnState, cp);\n  }\n}\nexports.Tokenizer = Tokenizer;\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"script"}